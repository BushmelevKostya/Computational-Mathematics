0:20
Good afternoon I'm really excited to be a i'm talking to so many programmers of automatic
0:26
computing machines as you know computing is becoming more and more important our society this now
0:32
literally thousands of computers around the world and they're being used from everything
0:37
from business and accounting to scientific experiments and who knows what they're going to be used for. so more more computers
0:45
and coming down in price coming down size a computer used to be the size of this entire hall and now they've shrunk to really
0:52
tiny proportions so is this this time a really rapid change in the field of computing
0:59
so I thought to be interested have a look ahead a little bit to the future programming and think about given what we know now
1:08
what programming might be like say forty years from now so what I'm going to talk about today there's been some really interesting research
1:16
has been done just the last ten years or so and i think is have implications for what program he might be like in the future so
1:26
there is 4 big ideas kind of 4 big topics that I want to talk about um that come out of her recent research but
1:33
before I get to those for big ideas I want to talk about the nature of adopting ideas in the first place
1:39
so basically what we've we notice is that technology just quickly people's minds change slowly
1:46
so it easier to adopt new technologies it can be hard to adopt new ways of thinking so
1:54
technology wise Gordon Moore He has this company called Intel and he observed about ten years ago that
2:04
computing capacity was a increasing exponentially over time because extrapolate is out to about now and
2:11
he's been right on target and who knows how long will keep going but it seem pretty reasonable so the lesson to be drawn from this is that
2:19
we can kinda take this for granted because if we just wait our computer get faster to get more capable we can just wait and that's just gonna happen what won't just happen if we wait
2:28
is peoplee changing people adopting new ideas so as an example that I'm sure you all remember this guy
2:35
the old IBM 650 Steve you know IBM's first kind of general purpose mass-produce computer
2:43
a lot of us cut our teeth programming on this guy and and in the beginning right we all programmed in
2:50
absolute binary when we code it was literally writing numeric codes for each instruction and that those what we did that was programming
2:57
and then afters some years that Stan Poley came along and he invented this thing they called an assembler
3:06
so that was the symbolic optimizing assembly program this language where you could write
3:13
in words if you wanted the computer to add something about the word add you could use symbolic variable names instead of hard coding memory addresses
3:21
it is this much more powerful way of thinking about programming you were much more productive made much fewer errors
3:28
assembly was shown to these guys the guys coding in a binary and they just weren't interested at all
3:34
they just didn't get it they didn't see any value in doing this stuff so there can be a lot of resistance to new ways of working
3:44
that require you to have unlearn what you've already learned and think in new ways and there can even be like outright hostility
3:51
so John von Neumann the great scientist who invented the von neumann computer architecture that we use and so many other
3:58
things he said I don't see why anybody woud need anything other than machine code and he
4:05
one-time so he had a bunch of students and students were all kinda coding along and in binary and one time one of his students took a little time out to write
4:13
out his own little assembler so he could write in assembly and by von neumann was furious at him furious that he would waste precious machine time
4:20
doing the assembly that was clerical work that was supposed to be for people right and so
4:27
we saw the same story happened just a little bit later when john backus and friends came up with us idea they called fortran
4:35
this is so call high-level language where you could write out your formulas as if your writing mathmatical notation you could write out loops
4:42
and this was shown to the assembly programmers and once again they just they weren't interested they don't see any value in that they just didn't get it so
4:50
um I want you to keep this in mind as I talk about the four big ideas that I'm going to talk about today that
4:58
it's easy to think that technology technology is always getting better because Moore's law because computers are getting
5:03
always more capable but ideas that require people to unlearn what they've learned and think in new ways there's often
5:10
enormous amount of resistance people over here they think they know what they're doing they think they know a programming is
5:16
this programming that's not programming and so there's going to be a lot of resistance to adopting new ideas
5:26
the four ideas I want talk about today this is all coming out a very recent research the first one is today we writer programs
5:34
in code. We write a basic list of instructions for the computer to do there's been some really interesting research on direct manipulation of data
5:42
where you directly manipulate the data structures and that implicitly builds up a program
5:47
for the computer to follow second I want to talk about today we write procedures basically here's a procedure for computer to do
5:54
um interesting research on go on programming using goals telling the computer what you want not how to do it the and the computer itself figures ou how to
6:02
do it number three today we program using lists lines of text
6:07
in text files um people are doing something really remarkable just like in the last five or ten years they're hooking video displays
6:15
up to computers and when you do that everything changes like start thinking about spatial representations of information and the fourth thing
6:23
is we program in a sequential programming model is basically here's a bunch of instructions computer does them one after the other but
6:30
hardware changing soon we're goona see massively parallel hardware and we're gonna need a sound parallel program model to program
6:38
on a hard work so the first thing i wanna talk about that direct manipulation of data
6:45
and I'm gonna show this project that Ivan Sutherland did PhD thesis about ten years ago
6:53
the system called sketchpad and sketch pad was a system that allowed you to draw pictures on a video display
7:00
so he took his light pen and put on the screen and so here try that draw the line drew that line drew more lines drew this little top
7:08
he's trying to draw a rivet here and he's drawing it really sloppily it's kinda tilted off to the side is kinda misshapen
7:16
so what he does is he then he holds down a switch and indicates
7:23
a couple these lines to the computer system indicating that he wants these lines to be mutually perpendicular
7:29
so the system runs an iterative solver kinda wheels the lines around and figures out how to turn them into
7:37
something that mutually perpendicular how to turn them into a rectangle so basically he
7:45
the system doesn't know anything about rectangles he was able to get it to draw a rectangle by directly applying the set of constraints
7:52
and what makes this a program as opposed to just a picture is that these constraints are dynamically maintained so
7:59
he's got his rivet that he drew and he resized this corner of it and kinda resize some other things
8:05
the solver kicks back in turns back into a perfect rectangle so essentially he's created a program
8:12
that draws a rectangle but he didn't do it by writing code he did by directly manipulating the data and directly applying
8:18
a set of constraints to them and so this kind of a simple example and then he went off and did fancier things like here's a bridge simulation
8:28
so it actually simulates the physics for bridge he drew this by hand the um the numbers here represent the tension in those
8:35
particular spans of the bridge and he can vary the weight that the load that's hanging off of the bridge and it kinda
8:42
deforms and um the system the sketchpad system doesn't know anything about bridges
8:48
he creates this bridge simulation program by directly drawing and by directly applying asserts that a um
8:55
very general constraints so I definitely see this as something that's going to be really important
9:02
in um 30 40 years from now I can imagine programming by directly manipulating data structures and let that build up
9:09
the the code but especially for things that are visual or physical like this so if say in a few decades we get some sort of document
9:18
format on some sort of web of computers I guess um I'm sure we're gonna be creating all those documents by direct manipulation there won't be any
9:27
markup languages or stylesheet languages right? that would that would make no sense Ivan Sutherland showed us how to do it
9:34
back your 1962 so it's all gonna be direct manipulation in the future and it's going to be fantastic
9:41
so the second thing I want to talk about is programming using goals
9:48
so we saw a little bit of this um with sketch pads constraint system so
9:55
Ivan Sutherland wanted to draw a rectangle he didn't write a procedure to like draw each side of the rectangle he
10:01
apply to set of constraints and the system itself kinda figured out how to draw that rectangle so he kinda said what he wanted
10:09
I want things to be mutually perpendicular he didn't say how to do it the solver figured out how to do it so another great example of that
10:17
just came up a few years ago Carl Hewitt is doing this system called planner which is really great it actually goes in both directions so it can reason
10:25
forward procedurally it can reason backwards from goals so if you tell planner that
10:30
apple red then if you get an apple knows ahah it's red but you can also say I want something red
10:38
and I'll say oh lets try an apple so you can express your program in terms of the goals the results that you want from the program
10:45
but you can also provide procedural strategies for meeting certain types of subgoals really um really interesting way of thinking a
10:52
programming and this led to another system a few years later called prologue
10:58
which just kept the backwards part of planner so in prologue you can express your program as goals and the system itself uses a search or whatever to try to
11:06
figure out how to meet those goals so this is leading to a genre of programming that's called logic programming
11:11
but that's that's not really important part here what's important is expressed your program as what you want
11:18
to not a setup instructions on how to do it letting the computer itself figure out how to do it another example of
11:25
that same sorta concept is pattern matching so I'm sure you remember on you all remember snobol
11:33
it's the a text manipulation language give a bunch of text you want to shoot it throw a snow ball
11:38
script or program at it and um snobol had a built in features for pattern matching
11:44
so you can express some patterns that you want to a match against a text a little bit later Ken Thompson so is over at bell labs working on this system they
11:52
call Unix um I know right? Unix but um he adopted ?'s notion of regular expressions
12:00
to do pattern matching on text so when you have pattern matching if you want to digest a big bunch of text
12:08
you don't go and write a parser that kinda goes procedurally through it you provide a pattern this kind of template this is the sort of thing i'm looking for.
12:15
and the system itself figures out how to match the text against that pattern so
12:23
all these examples a sketch pads constraints planner prologue pattern matching again they're all
12:30
all examples of giving the computer a high-level goals saying here the sort of thing i'm looking for letting the computer itself figure out how to do
12:37
it and we're seeing a little bit of that sorta thing in optimizing compilers but I think it's gonna be really prevalent
12:43
and few decades from now and the reason that this is going to be so important this goal directed stuff has to do
12:50
with this this idea that look litres kicking around so
12:57
as you all know Licklider is heading up up ARPA the government funding agency and he's been pushing this idea of
13:04
a global network of computers just taking all the computers in the world hooking them up to each other
13:09
and he calls it the intergalactic computer network because he knows the engineers always deliver the minimum so if he asks for a
13:17
network that spans the galaxy he's hopes to get one that at least spans the world and people are calling this
13:24
the ARPANET now its no turning into some sort of inter net now it's kinda cute idea
13:31
might work and when you have this kind of global network of computers
13:37
you run into what Licklider calls the communicating with aliens problem so he put it here the promise is essentially the one discussed by science fiction writers
13:46
how do you get communication started among totally uncorrelated sapient beings I'll explain what he means by that
13:57
so say you've got this network of computers and you've got some program out here that was written by somebody at some
14:03
time in some language its speaks some protocol you've got another program over here written by somebody else some other time
14:09
speaks a totally different language written totally different language these two programs know nothing about each other but at some point
14:18
this program will figure out that there's a service needs from that program that they have to talk to each other so you've got these two programs
14:26
don't know anything about each other written totally different times and now they need to be able to communicate so how are they gonna do that
14:34
well only one real answer that scales that's actually going to work which is they have to figure out how to talk to
14:42
each other right they need to negotiate with each other that the probe each other if the dynamically figure out a common language
14:50
so they can exchange information and fulfill the goals that the human programmer gave to them so that's why this goal directed stuff is
14:58
gonna be so important when we have this internet is because you can't write a procedure it's because we won't know
15:04
the procedures for talking to these remote programs these programs themselves have to figure out the features for talking to each
15:10
other and fulfill higher level goals so this if we have this worldwide network I think that
15:17
this is the only model that's gonna scale what won't work would be a total disaster is
15:24
I'm gonna make up a term here API this notion that you have a human programmer that writes against
15:31
a fixed interface that's exposed by some remote program first of all this requires the programs already know about each other
15:39
right and when your writings this program in this one's language now they're tied together so the first program can go out
15:47
and hunt and find other programs that implement the same service they're tied together if this one's language changes
15:53
it breaks this one there it's really brittle it doesn't scale and worst of all you have
16:00
it is basically the machine code problem you have a human doing low-level details that should be taken care of by the machine
16:08
so I'm pretty confident this never happened we're not gonna have API's in the future where we are going to have
16:15
are programs that know how to figure out how to talk to each other and that's going to require programming goals
16:29
the third big idea that I wanna talk about is spatial representation of information so today
16:36
our programs are basically lots of lines of text a big file full of lines of text and that makes sense when
16:43
your program is a on a stack a punch cards or it's a paper tape or a magnetic tape this
16:48
very linear media makes sense to have your programs have linear form if you're using a teletype then a teletype is made for spitting out lines of text
16:57
that's what it does so of course your programs are going to be in lines of text but as I mentioned people are doing something really wild and crazy right
17:04
now which is hooking video displays up computers and when you have a video display hooked up to a computer you can start
17:10
thinking of your computers this kind of very dynamic sheet of paper where you can represent things spatially so
17:21
Doug Engelbart over SRI has this system that he calls on online system that he calls NLS
17:29
He gave a big demo five years ago you might have seen it and there's a lot of really remarkable things about this system one the most remarkable
17:36
is this notion of displaying information over a screen over a video screen so he has this device this um
17:45
this device called a mouse where you kinda rolled around the table it's hard to explain
17:50
but you can use this to point to different parts of the screen and indicate that you want more information about something that you're pointing to
17:58
and it also has this notion of different views of information so you can see here we have some data that's in a list
18:06
and then you can flip that over and look at that same data as this kind of 2 dimensional diagram
18:11
so really start to think about how can we represent information dynamic information spatially
18:18
another great system kind of about about the same time coming out of the RAND Corporation called GRAIL and this is a system for
18:27
programming using flow charts on a video display and the input device here is a a stylus on a tablet
18:34
and that you can drop draw these flow charts and let me show you how that works
18:42
the programmer is drawing this box and just totally free handing it and he draws a box and the system recognizes that it's a box and turns it
18:50
into a flow chart box so assigns semantic meaning to these drawings that he's doing he wants to give it a label
18:58
so he just start writing letters the system recognizes his handwriting
19:04
1968 system recognizes handwriting turns it into text here he connects up this
19:12
box to that one with the line and so on so it's all very direct manipulation
19:18
if he wants to get rid this line he just kinda scruples it out and it goes away ands so really thinking about were programming means when you have a video
19:25
display when you can express things in two dimensions but when i'm talking about spatial representation of information I'm not just
19:32
talking about things like flow charts so um xerox has
19:37
a little research center in Palo Alto with some kids over there working on something that they call Smalltalk
19:42
and in Smalltalk the source code is expressed in text but um
19:49
there's no like big long text file with whole bunch of code in it it's organized in a spatial fashion so here's what they call a
19:56
browser so in this list here here's all the collection of classes here's all the class is that collection here's all protocols in that class here's all the
20:04
method in that protocol and here's the source code for that particular method
20:09
so the method definitions are text but they're not a one huge line of text they're organized spatially
20:17
so you can get around the system very quickly and see what's going on so between Engelbart's NLS Grail
20:24
small talk is very different ways of representing information spatially so I'm totally confident than 40 years we won't be writing code in text files
20:34
right we've been shown the way and as a side note
20:44
all these system I just showed you and Engelbart's system Grail Smalltalk on this thing that's going on at University of Illinois call
20:51
Plato also really interesting system these are part of this new wave of interactive computing where you sit at the computer and you're
21:00
actually interacting with the computer in real time and these guys know that they're trying to prove out this new concept
21:07
and so they've designed the system from the very bottom to have an immediate response the user interface is always immediately responsive
21:15
you interact with anything you immediately get a response so it's kinda of simulating a physical object
21:21
and so if interactive computing takes off and I think it will then i think is pretty obvious that
21:29
in forty years our User Interfaces if you interact with them you'll never experience any kind of delay or lag
21:36
right because these guys proved how important is to have immediate responsive UI and
21:42
they were doing this in the in the sixties so as our computers get a million times faster obviously there's no reason to have any kind of delay or lag in the operating system
21:50
in the in the user interface so that's gonna be really exciting
21:57
the forth thing that I want to talk about is um parallel programming
22:04
so today our programs are basically a sequence of instructions computer do this then do that and do that and do
22:11
that and one of the reasons that we program in this sequential model
22:17
has to do with the hardware so we're we've been using this computer architecture
22:24
called the von neumann computer architecture where you have a processor and that's hooked up to a big memory fetching words from memory
22:32
and um so the sequential program model makes sense when you just have one
22:37
processor the processor can only do one thing at a time you give us list the things for the processor to do and it just kinda does
22:42
each one of those um one characteristic of the von neumann architecture though is that
22:51
most to this memory is idle most of the time you've got this little processor over here and it's kind of processing as fast as it
22:58
can but only one word memory is ever being accessed the rest the memories just kind of sitting there waiting and
23:05
that works when when your processor is made out of vacuum tubes or relays and it's kinda of big an expensive and your memory is made
23:14
out of core or a rotating drum is also big and expensive different then you can kind of get away with that but
23:22
we're starting to see an incredible invention coming into the field of computing right now which is I think gonna change
23:29
everything and that is the integrated circuit semiconductor integrated circuit
23:35
so this is a thingthat the a company called Intel made it's called the microprocessor and it's an entire processor
23:44
on a single piece of silicon so the entire processor is just made out of transistors and
23:49
a transistors just a little picture you etch into silicon and the entire circuit just like one big complicated picture that you etch into
23:55
silicon so our processors are just made out of transistors and silicon
24:00
our memories as well are also going to be made of transistors on silicon it's all the same stuff
24:08
so when you look at the von neumann architecture from that perspective you've got these transistors over here that are working really hard to process
24:14
things it got this huge array of transistors over here most of which are just kinda sitting waiting they're not processing
24:23
not doing anything and so if you want to put those transistors to work
24:30
you actually want to maximize um the amount of processing that you can get out the piece of silicon
24:37
you need to start looking at things that are more like this
24:43
right so what computers want to be on silicon is they want to be lots of little computers like a huge array of tiny
24:50
little computers with their own processor their own little state doing their own thing communicating with each other that's how you maximize the amount of compute per area of silicon
25:00
and it scales so when the transistor gets smaller when the silicon die gets bigger you have all this extra space you just filled up with more processors
25:09
right done real easy this is the kind of architecture we're going to be programming on the in the
25:16
future unless you know unless Intel somehow get a stranglehold microprocessor
25:22
market and pushes this architecture forward thirty years but that's not gonna happen we're going to programming on these things
25:28
and when you have this hardware you have to start thinking about how do how do we program on that what's our programming model for this sort of
25:34
hardware and the way that we do programming today
25:40
is with threads and locks right you have a few sequential thread for control and you can pretend that they're going in parallel by
25:47
multiplex the microprocessor and they try to lock each other out from shared resources
25:52
and like this is never gonna work right this does not scale you can't reason about hundreds of threads all banging on the same
25:59
shared memory at the same time threads and locks they're a dead end
26:05
right so I think in forty years if we're still using threads and locks we should like pack up and go home cuz we've
26:10
clearly failed as an engineering field if it's not threads and locks then what's going to work
26:17
and Carl Hewitt and that's the same Carl Hewitt that did planner came up with this idea that he called the actor model
26:25
so the actor model is a model computation that's inspired by physics so in physics you've got all these particles and
26:32
all the particles are just independently doing their own thing and they have their own little states and they interact with the ones that are around
26:39
them and Carl Hewitt was thinking of computer processes in the same way got a whole bunch processes and they're all kind of asynchronously doing their own little thing have their
26:47
own state and they're sending messages to each other so really interesting really new and exciting way of thinking about programming
26:55
so a lot is kinda heating up right now Gilles Khan and France has some ideas I think Tony Hoare getting into it with something he's
27:02
gonna be calling Communicating Sequential Processes and maybe even Robin Milner's going to join the party so
27:09
really exciting stuff happening here now for this talk the details of these particular models don't really matter
27:16
um I do think it would be kinda cool if the actor models was like picked up by the Swedish phone company or something that would be kind of
27:24
weird but but what matters here is we are gonna have massively parallel hardware
27:32
we need a sound parallel programming model that fits the hardware and something like this
27:38
is is going to be what we're gonna be using
27:46
so those are the four things I want to talk about direct manipulation of data
27:54
something like sketch pad where you're drawing pictures dynamically adding contraints to those pictures
28:00
directly manipulating the data structures instead of writing instructions for the program programming using goals and constraints things like sketch pads constraints
28:09
planner and prologue um regular expressions other types of pattern matching where you're telling the computer
28:16
what you want to do and the computer itself has solvers the figure out how to do that
28:21
spatial representations of information we're not gonna have text files anymore we're going to be representing information spatially cuz we have video displays
28:29
and fundamentally parallel ways of thinking parallel hardware parallel program models um no more threads and locks no more
28:37
sequential thinking so those are the four things I wanted to talk about
28:44
and you know I've tried to make some predictions about the future and you can't really predict the future right so these are some good ideas
28:53
I don't know what's gonna happen to them ideas kinda split and merge in go in and out of fashion so you know anything could happen
29:01
but I do think that it would be kind of a shame if in forty years we're still coding in procedures
29:08
in text files in a sequential programming model I think that would suggest we didn't learn anything from this really
29:17
fertile period in computer science so that would kinda be a tragedy but
29:24
even more of a tragedy than these ideas not being used would be if these ideas were forgotten
29:30
if if anybody were ever to be shown this stuff and actually be surprised by it right but even that's not the biggest tragedy
29:38
that's not the real tragedy the real tragedy would be if people forgot that you could have new ideas about programming models
29:45
in the first place so let me explain what I mean by that the
29:52
here's what I think the worst case scenario would be is if the next generation programmers grows up
29:59
never being exposed to these ideas the next generation the next generation programmers grows up only being shown one way of thinking
30:06
about programming so they work on that way programming they the flesh out all the details
30:11
they you know kinda solve that particular model programming they figured it all out and then they teach that
30:18
to the next generation so that second generation then grows up thinking Oh it's all been figured out we know what programming is
30:26
we know what we're doing they grow up with dogma once you grow up with dogma it's really hard
30:35
to break out of it do you know the reason why all these ideas and so many other good ideas came
30:42
about in this particular time period the sixties early seventies why did it all happen
30:48
it's because technology it was late enough that technology had kinda got to the point where you
30:55
actually could do things with computers but it's still early enough that nobody knew what programming was
31:03
nobody knew programming was supposed to be and they knew they didn't know so they just like tried everything
31:08
their minds were totally free and they just like said maybe we could program like this maybe we could program like that they just you know tried anything they could think of
31:18
so the most dangerous thought
31:25
that you can have as a creative person is to think that you know what you're doing
31:31
because once you think you know what you're doing you stop looking around for other ways of doing things and you stop being able to see
31:38
other ways of doing things you become blind you become like like these guys over here coding along in binary
31:46
someone shows them assembly language someone shows them fortran this they can't even see it it just goes right over their head
31:53
because they know what they're doing they know what programming is this is programming that's not programming and so they totally miss out on this much more
32:00
powerful way of thinking so the message of this talk
32:07
you know it's not really it's not really the stuff right the message on his talk is if you don't want to be
32:14
this guy if you want to be open and receptive to new ways of thinking to invent new ways of thinking
32:22
I think the first step is you have to say to yourself I don't know what I'm doing we as a field
32:28
don't know what we're doing I think you have to say we don't know what programming is we don't know what computing is we don't even know
32:35
what a computer is and once you truly understand that and once you truly believe that
32:43
then you're free and you can think anything thank you